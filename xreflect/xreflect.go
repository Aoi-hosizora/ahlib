package xreflect

import (
	"errors"
	"fmt"
	"math"
	"reflect"
	"runtime"
	"strconv"
	"strings"
	"unsafe"
)

// ========================
// unexported field related
// ========================

// GetUnexportedField gets the reflect.Value of unexported struct field's.
//
// Example:
// 	GetUnexportedField(reflect.ValueOf(app).Elem().FieldByName("noMethod")).Interface().(gin.HandlersChain)             // (*app).noMethod is a gin.HandlersChain
// 	GetUnexportedField(FieldValueOf(app, "noMethod")).Interface().(gin.HandlersChain)                                   // <- or in this way
// 	GetUnexportedField(reflect.ValueOf(trans).Elem().FieldByName("translations")).MapIndex(reflect.ValueOf("required")) // (*trans).translations is a map[string]xxx
// 	GetUnexportedField(FieldValueOf(trans, "translations")).Interface().(gin.HandlersChain)                             // <- or in this way
func GetUnexportedField(field reflect.Value) reflect.Value {
	return reflect.NewAt(field.Type(), unsafe.Pointer(field.UnsafeAddr())).Elem()
}

// SetUnexportedField sets reflect.Value to unexported struct field, this can also be implemented by using the reflect.Value returned from GetUnexportedField.
//
// Example:
// 	SetUnexportedField(reflect.ValueOf(ctx).Elem().FieldByName("fullPath"), reflect.ValueOf(newFullPath)) // (*ctx).fullPath and newFullPath is a string
// 	SetUnexportedField(FieldValueOf(ctx, "fullPath"), reflect.ValueOf(newFullPath))                       // <- or in this way
// 	SetUnexportedField(reflect.ValueOf(val).Elem().FieldByName("tagNameFunc"), reflect.ValueOf(nilFunc))  // (*val).tagNameFunc and nilFunc is a func
// 	SetUnexportedField(FieldValueOf(val, "tagNameFunc"), reflect.ValueOf(newFullPath))                    // <- or in this way
func SetUnexportedField(field reflect.Value, value reflect.Value) {
	reflect.NewAt(field.Type(), unsafe.Pointer(field.UnsafeAddr())).Elem().Set(value)
}

const (
	panicNilInterface           = "xreflect: nil interface"
	panicNilPtr                 = "xreflect: nil pointer"
	panicNonStructOrPtrOfStruct = "xreflect: not a struct or pointers of struct"
	panicNonexistentField       = "xreflect: nonexistent struct field"
)

// FieldValueOf returns the reflect.Value of specific struct field from given struct or pointers of struct.
//
// Example:
// 	FieldValueOf(app, "noMethod")       // equals to reflect.ValueOf(app)[.Elem()*].FieldByName("noMethod")
// 	FieldValueOf(trans, "translations") // equals to reflect.ValueOf(trans)[.Elem()*].FieldByName("translations")
func FieldValueOf(i interface{}, name string) reflect.Value {
	if i == nil {
		panic(panicNilInterface)
	}
	val := reflect.ValueOf(i)
	for val.Kind() == reflect.Ptr && !val.IsNil() {
		val = val.Elem()
	}

	if val.Kind() == reflect.Ptr && val.IsNil() {
		panic(panicNilPtr)
	}
	if val.Kind() != reflect.Struct {
		panic(panicNonStructOrPtrOfStruct)
	}
	fval := val.FieldByName(name)
	if !fval.IsValid() { // not existed
		panic(panicNonexistentField)
	}
	return fval
}

// ================
// get func related
// ================

const (
	panicNilFuncPtr      = "xreflect: nil funcPtr"
	panicNotFuncPtrValue = "xreflect: not function-pointer value"

	errFunctionNotFound = "xreflect: function \"%s\" is not found"
)

// Following functions about GetFunc are referred from:
// https://github.com/alangpierce/go-forceexport/blob/8f1d6941cd/forceexport.go#L10-L22
// http://www.alangpierce.com/blog/2016/03/17/adventures-in-go-accessing-unexported-functions

// GetFuncByPC finds specific function value and sets to passed function pointer parameter (in `*func` type) using given function pc address, panics when
// using invalid funcPtr. Note that this supports both exported and unexported functions, and it will panic until you call the function if pc is invalid.
//
// Example:
// 	TODO
// 	TODO
func GetFuncByPC(funcPtr interface{}, pc uintptr) {
	if funcPtr == nil {
		panic(panicNilFuncPtr)
	}
	funcPtrVal := reflect.ValueOf(funcPtr)
	if funcPtrVal.Kind() != reflect.Ptr {
		panic(panicNotFuncPtrValue)
	}
	funcVal := funcPtrVal.Elem()
	if funcVal.Kind() != reflect.Func {
		panic(panicNotFuncPtrValue)
	}

	newFuncVal := reflect.MakeFunc(funcVal.Type(), nil)
	((*funcval)(unsafe.Pointer(reflect.ValueOf(newFuncVal).FieldByName("ptr").Pointer()))).fn = pc
	funcVal.Set(newFuncVal)
}

// funcval is the same as runtime.funcval, represents the internal value of simple function value.
type funcval struct {
	fn uintptr
}

//go:linkname firstmoduledata runtime.firstmoduledata
var firstmoduledata moduledata

// FuncForName finds and returns a runtime.Func slice (concluding function's PC address, or said "fn" address for funcval) using given function name, is
// similar with runtime.FuncForPC, but returns error if no function is found. Note that there may be several functions with the same name (especially for
// "<autogenerated>"), you can read the source code of runtime.FuncForPC, runtime.findfunc and runtime.findmoduledatap in src/runtime/symtab.go for details.
//
// Example:
// 	fns1, _ := FuncForName("time.Now")
// 	pc1 := fns1[0].Entry() // runtime.FuncForPC(pc1).Name() == "time.Now"
// 	fns2, _ := FuncForName("time.runtimeNano")
// 	pc2 := fns2[0].Entry() // runtime.FuncForPC(pc2).Name() == "time.runtimeNano"
// 	fns3, _ := FuncForName("github.com/Aoi-hosizora/ahlib/xreflect.FuncForName")
// 	pc3 := fns3[0].Entry() // runtime.FuncForPC(pc3).Name() == "github.com/Aoi-hosizora/ahlib/xreflect.FuncForName"
func FuncForName(name string) (functions []*runtime.Func, err error) {
	functions = make([]*runtime.Func, 0)
	for datap := &firstmoduledata; datap != nil; datap = datap.next {
		if len(datap.pclntable) == 0 {
			continue
		}
		for _, ftab := range datap.ftab {
			f := (*runtime.Func)(unsafe.Pointer(&datap.pclntable[ftab.funcoff]))
			if f.Name() == name {
				functions = append(functions, f)
			}
		}
	}
	if len(functions) > 0 {
		return functions, nil
	}
	return nil, fmt.Errorf(errFunctionNotFound, name)
}

// For calling unexported struct methods, visit https://github.com/spance/go-callprivate/blob/master/examples.go#L20-L22.

// =================
// IsXXXKind related
// =================

// IsIntKind checks if given reflect.Kind is int kinds or not.
func IsIntKind(kind reflect.Kind) bool {
	return kind == reflect.Int || kind == reflect.Int8 || kind == reflect.Int16 || kind == reflect.Int32 || kind == reflect.Int64
}

// IsUintKind checks if given reflect.Kind is uint kinds or not.
func IsUintKind(kind reflect.Kind) bool {
	return kind == reflect.Uint || kind == reflect.Uint8 || kind == reflect.Uint16 || kind == reflect.Uint32 || kind == reflect.Uint64 || kind == reflect.Uintptr
}

// IsFloatKind checks if given reflect.Kind is float kinds or not.
func IsFloatKind(kind reflect.Kind) bool {
	return kind == reflect.Float32 || kind == reflect.Float64
}

// IsComplexKind checks if given reflect.Kind is complex kinds or not.
func IsComplexKind(kind reflect.Kind) bool {
	return kind == reflect.Complex64 || kind == reflect.Complex128
}

// IsLenGettableKind checks if given reflect.Kind's related reflect.Value can use Len() method or not.
func IsLenGettableKind(kind reflect.Kind) bool {
	return kind == reflect.String || kind == reflect.Array || kind == reflect.Slice || kind == reflect.Map || kind == reflect.Chan
}

// IsNillableKind checks if given reflect.Kind's related reflect.Value can use IsNil() method or not.
func IsNillableKind(kind reflect.Kind) bool {
	return kind == reflect.Ptr || kind == reflect.Func || kind == reflect.Interface || kind == reflect.UnsafePointer ||
		kind == reflect.Slice || kind == reflect.Map || kind == reflect.Chan
}

// ==============
// mass functions
// ==============

// IsEmptyValue checks if a value is an empty value, this function do never panic for all parameters.
// Support types: (all types)
// 	1. numeric:    int, intX, uint, uintX, uintptr, floatX, complexX, bool.
// 	2. collection: string, array, slice, map, chan.
// 	3. wrapper:    interface, ptr, unsafePtr.
// 	4. composite:  struct.
// 	5. function:   func.
func IsEmptyValue(i interface{}) bool {
	return isEmptyValueInternal(reflect.ValueOf(i))
}

// isEmptyValueInternal is the internal implementation of IsEmptyValue.
func isEmptyValueInternal(val reflect.Value) bool {
	switch val.Kind() {
	case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
		return val.Int() == 0
	case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:
		return val.Uint() == 0
	case reflect.Float32, reflect.Float64:
		return math.Float64bits(val.Float()) == 0
	case reflect.Complex64, reflect.Complex128:
		c := val.Complex()
		return math.Float64bits(real(c)) == 0 && math.Float64bits(imag(c)) == 0
	case reflect.Bool:
		return !val.Bool()
	case reflect.String, reflect.Array:
		return val.Len() == 0
	case reflect.Slice, reflect.Map, reflect.Chan:
		return val.IsNil() || val.Len() == 0
	case reflect.Interface, reflect.Ptr, reflect.UnsafePointer, reflect.Func:
		return val.IsNil()
	case reflect.Struct:
		for i := 0; i < val.NumField(); i++ {
			if !isEmptyValueInternal(val.Field(i)) {
				return false
			}
		}
		return true
	default:
		// reflect.Invalid, that is (SomeInterface)(nil)
		return true
	}
}

const (
	panicNilMap = "xreflect: nil map"
	panicNonMap = "xreflect: not a map"
)

// GetMapB returns the B value from the inputted map value. Note that this is an unsafe function, and the returned value may change in different Go versions.
func GetMapB(m interface{}) uint8 {
	if m == nil {
		panic(panicNilMap)
	}
	typ := reflect.TypeOf(m)
	if typ.Kind() != reflect.Map {
		panic(panicNonMap)
	}

	type eface struct {
		_type unsafe.Pointer
		data  unsafe.Pointer
	}
	type hmap struct {
		count int
		flags uint8
		B     uint8
		// ...
	}

	// https://hackernoon.com/some-insights-on-maps-in-golang-rm5v3ywh
	ei := *(*eface)(unsafe.Pointer(&m))
	mobj := *(*hmap)(ei.data)
	return mobj.B
}

// GetMapBuckets returns the B value and the buckets count from the inputted map value. Note that this is an unsafe function, and the returned B value may
// change in different Go versions, while the buckets count will always equal to 2^B.
func GetMapBuckets(m interface{}) (b uint8, buckets uint64) {
	b = GetMapB(m)
	buckets = uint64(math.Pow(2, float64(b)))
	return b, buckets
}

// =========================
// FillDefaultFields related
// =========================

var (
	errNotStructPtr = errors.New("xreflect: using not a pointer of a structure type")
)

const (
	panicInvalidDefaultType = "xreflect: parsing '%s' as the default value of field '%s' failed: %v"
)

// FillDefaultFields fills struct fields with "default" tag recursively, returns true if any value is set or filled, returns error only when given parameter
// is not a pointer of struct, panics when using mismatched default value type and field type.
//
// Example:
// 	type Config struct {
// 		Host string `yaml:"host" default:"127.0.0.1"`
// 		Port int32  `yaml:"port" default:"3306"`
// 		// ...
// 	}
// 	cfg := &Config{}
// 	// unmarshal cfg...
// 	_, err = FillDefaultFields(cfg)
func FillDefaultFields(s interface{}) (allFilled bool, err error) {
	val := reflect.ValueOf(s)
	if val.Kind() != reflect.Ptr {
		return false, errNotStructPtr
	}
	val = val.Elem()
	if val.Kind() != reflect.Struct {
		return false, errNotStructPtr
	}
	typ := val.Type()

	filled := false
	for i := 0; i < typ.NumField(); i++ {
		sf := typ.Field(i)
		if sf.PkgPath == "" && sf.Type != nil { // sf.IsExported()
			filled = fillDefaultFieldInternal(sf.Type, val.Field(i), sf.Tag, sf.Name, nil) || filled
		}
	}

	return filled, nil
}

// _defaultTag is the tag "default" used in FillDefaultFields.
var _defaultTag = "default"

// SetDefaultTagName sets the default tag name that is used in FillDefaultFields, defaults to "default".
func SetDefaultTagName(tag string) {
	if tag != "" {
		_defaultTag = tag
	}
}

// fillDefaultFieldInternal is the internal implementation of FillDefaultFields, this sets the default value using given reflect.StructTag to given reflect.Value.
func fillDefaultFieldInternal(ftyp reflect.Type, fval reflect.Value, fieldTag reflect.StructTag, fieldName string, setMapItem func(v reflect.Value)) bool {
	k := ftyp.Kind()
	switch {
	case k == reflect.Struct && ftyp.NumField() == 0,
		k == reflect.Array && ftyp.Len() == 0,
		(k == reflect.Slice || k == reflect.Map) && (fval.IsNil() || fval.Len() == 0),
		k == reflect.Invalid, k == reflect.Func, k == reflect.Chan, k == reflect.Interface, k == reflect.UnsafePointer:
		return false
	case k == reflect.Slice:
		filled := false
		etyp := ftyp.Elem()
		for i := 0; i < fval.Len(); i++ {
			filled = fillDefaultFieldInternal(etyp, fval.Index(i), fieldTag, fmt.Sprintf("(%s)[%d]", fieldName, i), nil) || filled
		}
		// <<< no need to setMapItem, for slice stores items in heap
		return filled
	case k == reflect.Array:
		filled := false
		cached := make(map[int]reflect.Value)
		etyp := ftyp.Elem()
		for i := 0; i < ftyp.Len(); i++ {
			i := i
			filled = fillDefaultFieldInternal(etyp, fval.Index(i), fieldTag, fmt.Sprintf("(%s)[%d]", fieldName, i), func(v reflect.Value) { cached[i] = v }) || filled
		}
		if len(cached) > 0 {
			newArray := reflect.New(ftyp).Elem()
			newArray.Set(fval) // use typedmemmove, faster then for-iterate
			for i := 0; i < ftyp.Len(); i++ {
				if newVal, ok := cached[i]; ok {
					newArray.Index(i).Set(newVal)
				}
			}
			setMapItem(newArray) // <<< replace the whole array to map item
		}
		return filled
	case k == reflect.Ptr:
		etyp := ftyp.Elem()
		if !fval.IsNil() {
			return fillDefaultFieldInternal(etyp, fval.Elem(), fieldTag, fmt.Sprintf("*(%s)", fieldName), nil)
		}
		newVal := reflect.New(etyp)
		filled := fillDefaultFieldInternal(etyp, newVal.Elem(), fieldTag, fmt.Sprintf("*(%s)", fieldName), nil)
		if filled {
			if fval.CanSet() {
				fval.Set(newVal)
			} else {
				setMapItem(newVal) // <<< replace the whole pointer to map item for values those cannot be set directly
			}
		}
		return filled
	case k == reflect.Map:
		filled := false
		etyp := ftyp.Elem()
		for _, key := range fval.MapKeys() {
			key := key
			filled = fillDefaultFieldInternal(etyp, fval.MapIndex(key), fieldTag, fmt.Sprintf("(%s)[\"%s\"]", fieldName, key.String()), func(v reflect.Value) {
				fval.SetMapIndex(key, v)
				// non-reference values (or items) got from map by index directly can not be addressed (or be written) !!!
			}) || filled
		}
		return filled
	case k == reflect.Struct:
		filled := false
		cached := make(map[int]reflect.Value)
		for i := 0; i < ftyp.NumField(); i++ {
			i := i
			sf := ftyp.Field(i)
			if sf.PkgPath == "" { // sf.IsExported()
				filled = fillDefaultFieldInternal(sf.Type, fval.Field(i), sf.Tag, fmt.Sprintf("%s.%s", fieldName, sf.Name), func(v reflect.Value) { cached[i] = v }) || filled
			}
		}
		if len(cached) > 0 {
			newStruct := reflect.New(ftyp).Elem()
			newStruct.Set(fval) // include exported fields and unexported fields
			for i := 0; i < ftyp.NumField(); i++ {
				if newVal, ok := cached[i]; ok {
					newStruct.Field(i).Set(newVal)
				}
			}
			setMapItem(newStruct) // <<< replace the while struct to map item
		}
		return filled

	default:
		// =================
		// set default value to int / uint / float / bool / complex / string kinds of values
		defaul, ok := fieldTag.Lookup(_defaultTag)
		if !ok {
			return false
		}
		switch {
		case IsIntKind(k) && fval.Int() == 0:
			i, err := strconv.ParseInt(defaul, 10, 64)
			if err != nil {
				panic(fmt.Sprintf(panicInvalidDefaultType, defaul, fieldName, err))
			}
			if fval.CanSet() {
				fval.SetInt(i)
			} else { // must be in a map
				newVal := reflect.New(ftyp).Elem()
				newVal.SetInt(i)
				setMapItem(newVal)
			}
			return true
		case IsUintKind(k) && fval.Uint() == 0:
			u, err := strconv.ParseUint(defaul, 10, 64)
			if err != nil {
				panic(fmt.Sprintf(panicInvalidDefaultType, defaul, fieldName, err))
			}
			if fval.CanSet() {
				fval.SetUint(u)
			} else {
				newVal := reflect.New(ftyp).Elem()
				newVal.SetUint(u)
				setMapItem(newVal)
			}
			return true
		case IsFloatKind(k) && math.Float64bits(fval.Float()) == 0:
			f, err := strconv.ParseFloat(defaul, 64)
			if err != nil {
				panic(fmt.Sprintf(panicInvalidDefaultType, defaul, fieldName, err))
			}
			if fval.CanSet() {
				fval.SetFloat(f)
			} else {
				newVal := reflect.New(ftyp).Elem()
				newVal.SetFloat(f)
				setMapItem(newVal)
			}
			return true
		case IsComplexKind(k) && math.Float64bits(real(fval.Complex())) == 0 && math.Float64bits(imag(fval.Complex())) == 0:
			c, err := strconv.ParseComplex(defaul, 128)
			if err != nil {
				panic(fmt.Sprintf(panicInvalidDefaultType, defaul, fieldName, err))
			}
			if fval.CanSet() {
				fval.SetComplex(c)
			} else {
				newVal := reflect.New(ftyp).Elem()
				newVal.SetComplex(c)
				setMapItem(newVal)
			}
			return true
		case k == reflect.Bool && fval.Bool() == false:
			b := defaul == "1" || strings.ToLower(defaul) == "true" || strings.ToLower(defaul) == "t"
			if fval.CanSet() {
				fval.SetBool(b)
			} else {
				newVal := reflect.New(ftyp).Elem()
				newVal.SetBool(b)
				setMapItem(newVal)
			}
			return true
		case k == reflect.String && len(fval.String()) == 0:
			if fval.CanSet() {
				fval.SetString(defaul)
			} else {
				newVal := reflect.New(ftyp).Elem()
				newVal.SetString(defaul)
				setMapItem(newVal)
			}
			return true
		default:
			// don't need to fill default value to field / invalid kind
			return false
		}
	}
}
