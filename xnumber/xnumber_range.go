package xnumber

import (
	"math"
)

// checkSignedRange checks if the given signed integer from, to and step arguments is legal to represent a range, and also calculates the range slice capacity.
func checkSignedRange(from, to, step int64) (capacity int, isLegal bool) {
	if step > 0 && from < to {
		return int(math.Ceil(float64(to-from) / float64(step))), true
	} else if step < 0 && from > to {
		return int(math.Ceil(float64(from-to) / float64(-step))), true
	}
	return 0, false
}

// checkUnsignedRange checks if the given unsigned integer from, to and step arguments is legal to represent a range, and also calculates the range slice capacity.
func checkUnsignedRange(from, to, step uint64, reversedStep bool) (capacity int, isLegal bool) {
	if step != 0 && !reversedStep && from < to {
		return int(math.Ceil(float64(to-from) / float64(step))), true
	} else if step != 0 && reversedStep && from > to {
		return int(math.Ceil(float64(from-to) / float64(-step))), true
	}
	return 0, false
}

// ==============
// signed integer
// ==============

// IntRange returns an int slice as range [from, to) with step, note that a reversed range (to, from] can be generated by using a negative step.
func IntRange(from, to, step int) []int {
	capacity, ok := checkSignedRange(int64(from), int64(to), int64(step))
	if !ok {
		return nil
	}
	out := make([]int, 0, capacity)
	if step > 0 {
		for i := from; i < to; i += step {
			out = append(out, i)
			if OverflowWhenAddInt(i, step) {
				break
			}
		}
	} else {
		for i := from; i > to; i += step {
			out = append(out, i)
			if OverflowWhenAddInt(i, step) {
				break
			}
		}
	}
	return out
}

// Int8Range returns an int8 slice as range [from, to) with step, note that a reversed range (to, from] can be generated by using a negative step.
func Int8Range(from, to, step int8) []int8 {
	capacity, ok := checkSignedRange(int64(from), int64(to), int64(step))
	if !ok {
		return nil
	}
	out := make([]int8, 0, capacity)
	if step > 0 {
		for i := from; i < to; i += step {
			out = append(out, i)
			if OverflowWhenAddInt8(i, step) {
				break
			}
		}
	} else {
		for i := from; i > to; i += step {
			out = append(out, i)
			if OverflowWhenAddInt8(i, step) {
				break
			}
		}
	}
	return out
}

// Int16Range returns an int16 slice as range [from, to) with step, note that a reversed range (to, from] can be generated by using a negative step.
func Int16Range(from, to, step int16) []int16 {
	capacity, ok := checkSignedRange(int64(from), int64(to), int64(step))
	if !ok {
		return nil
	}
	out := make([]int16, 0, capacity)
	if step > 0 {
		for i := from; i < to; i += step {
			out = append(out, i)
			if OverflowWhenAddInt16(i, step) {
				break
			}
		}
	} else {
		for i := from; i > to; i += step {
			out = append(out, i)
			if OverflowWhenAddInt16(i, step) {
				break
			}
		}
	}
	return out
}

// Int32Range returns an int32 slice as range [from, to) with step, note that a reversed range (to, from] can be generated by using a negative step.
func Int32Range(from, to, step int32) []int32 {
	capacity, ok := checkSignedRange(int64(from), int64(to), int64(step))
	if !ok {
		return nil
	}
	out := make([]int32, 0, capacity)
	if step > 0 {
		for i := from; i < to; i += step {
			out = append(out, i)
			if OverflowWhenAddInt32(i, step) {
				break
			}
		}
	} else {
		for i := from; i > to; i += step {
			out = append(out, i)
			if OverflowWhenAddInt32(i, step) {
				break
			}
		}
	}
	return out
}

// Int64Range returns an int64 slice as range [from, to) with step, note that a reversed range (to, from] can be generated by using a negative step.
func Int64Range(from, to, step int64) []int64 {
	capacity, ok := checkSignedRange(from, to, step)
	if !ok {
		return nil
	}
	out := make([]int64, 0, capacity)
	if step > 0 {
		for i := from; i < to; i += step {
			out = append(out, i)
			if OverflowWhenAddInt64(i, step) {
				break
			}
		}
	} else {
		for i := from; i > to; i += step {
			out = append(out, i)
			if OverflowWhenAddInt64(i, step) {
				break
			}
		}
	}
	return out
}

// ================
// unsigned integer
// ================

// UintRange returns an uint slice as range [from, to) with step, note that a reversed range (to, from] can be generated by set the first value of reverseFlag to true.
func UintRange(from, to, step uint, reverseFlag ...bool) []uint {
	reservedStep := len(reverseFlag) >= 1 && reverseFlag[0]
	capacity, ok := checkUnsignedRange(uint64(from), uint64(to), uint64(step), reservedStep)
	if !ok {
		return nil
	}
	out := make([]uint, 0, capacity)
	if !reservedStep {
		for i := from; i < to; i += step {
			out = append(out, i)
			if OverflowWhenAddUint(i, step) {
				break
			}
		}
	} else {
		for i := from; i > to; i -= step {
			out = append(out, i)
			if OverflowWhenSubtractUint(i, step) {
				break
			}
		}
	}
	return out
}

// Uint8Range returns an uint8 slice as range [from, to) with step, note that a reversed range (to, from] can be generated by set the first value of reverseFlag to true.
func Uint8Range(from, to, step uint8, reverseFlag ...bool) []uint8 {
	reservedStep := len(reverseFlag) >= 1 && reverseFlag[0]
	capacity, ok := checkUnsignedRange(uint64(from), uint64(to), uint64(step), reservedStep)
	if !ok {
		return nil
	}
	out := make([]uint8, 0, capacity)
	if !reservedStep {
		for i := from; i < to; i += step {
			out = append(out, i)
			if OverflowWhenAddUint8(i, step) {
				break
			}
		}
	} else {
		for i := from; i > to; i -= step {
			out = append(out, i)
			if OverflowWhenSubtractUint8(i, step) {
				break
			}
		}
	}
	return out
}

// Uint16Range returns an uint16 slice as range [from, to) with step, note that a reversed range (to, from] can be generated by set the first value of reverseFlag to true.
func Uint16Range(from, to, step uint16, reverseFlag ...bool) []uint16 {
	reservedStep := len(reverseFlag) >= 1 && reverseFlag[0]
	capacity, ok := checkUnsignedRange(uint64(from), uint64(to), uint64(step), reservedStep)
	if !ok {
		return nil
	}
	out := make([]uint16, 0, capacity)
	if !reservedStep {
		for i := from; i < to; i += step {
			out = append(out, i)
			if OverflowWhenAddUint16(i, step) {
				break
			}
		}
	} else {
		for i := from; i > to; i -= step {
			out = append(out, i)
			if OverflowWhenSubtractUint16(i, step) {
				break
			}
		}
	}
	return out
}

// Uint32Range returns an uint32 slice as range [from, to) with step, note that a reversed range (to, from] can be generated by set the first value of reverseFlag to true.
func Uint32Range(from, to, step uint32, reverseFlag ...bool) []uint32 {
	reservedStep := len(reverseFlag) >= 1 && reverseFlag[0]
	capacity, ok := checkUnsignedRange(uint64(from), uint64(to), uint64(step), reservedStep)
	if !ok {
		return nil
	}
	out := make([]uint32, 0, capacity)
	if !reservedStep {
		for i := from; i < to; i += step {
			out = append(out, i)
			if OverflowWhenAddUint32(i, step) {
				break
			}
		}
	} else {
		for i := from; i > to; i -= step {
			out = append(out, i)
			if OverflowWhenSubtractUint32(i, step) {
				break
			}
		}
	}
	return out
}

// Uint64Range returns an uint64 slice as range [from, to) with step, note that a reversed range (to, from] can be generated by set the first value of reverseFlag to true.
func Uint64Range(from, to, step uint64, reverseFlag ...bool) []uint64 {
	reservedStep := len(reverseFlag) >= 1 && reverseFlag[0]
	capacity, ok := checkUnsignedRange(from, to, step, reservedStep)
	if !ok {
		return nil
	}
	out := make([]uint64, 0, capacity)
	if !reservedStep {
		for i := from; i < to; i += step {
			out = append(out, i)
			if OverflowWhenAddUint64(i, step) {
				break
			}
		}
	} else {
		for i := from; i > to; i -= step {
			out = append(out, i)
			if OverflowWhenSubtractUint64(i, step) {
				break
			}
		}
	}
	return out
}

// =============
// reverse slice
// =============

// ReverseIntSlice reverses the given int slice directly.
func ReverseIntSlice(s []int) {
	for i, j := 0, len(s)-1; i < j; i, j = i+1, j-1 {
		s[i], s[j] = s[j], s[i]
	}
}

// ReverseInt8Slice reverses the given int8 slice directly.
func ReverseInt8Slice(s []int8) {
	for i, j := 0, len(s)-1; i < j; i, j = i+1, j-1 {
		s[i], s[j] = s[j], s[i]
	}
}

// ReverseInt16Slice reverses the given int16 slice directly.
func ReverseInt16Slice(s []int16) {
	for i, j := 0, len(s)-1; i < j; i, j = i+1, j-1 {
		s[i], s[j] = s[j], s[i]
	}
}

// ReverseInt32Slice reverses the given int32 slice directly.
func ReverseInt32Slice(s []int32) {
	for i, j := 0, len(s)-1; i < j; i, j = i+1, j-1 {
		s[i], s[j] = s[j], s[i]
	}
}

// ReverseInt64Slice reverses the given int64 slice directly.
func ReverseInt64Slice(s []int64) {
	for i, j := 0, len(s)-1; i < j; i, j = i+1, j-1 {
		s[i], s[j] = s[j], s[i]
	}
}

// ReverseUintSlice reverses the given uint slice directly.
func ReverseUintSlice(s []uint) {
	for i, j := 0, len(s)-1; i < j; i, j = i+1, j-1 {
		s[i], s[j] = s[j], s[i]
	}
}

// ReverseUint8Slice reverses the given uint8 slice directly.
func ReverseUint8Slice(s []uint8) {
	for i, j := 0, len(s)-1; i < j; i, j = i+1, j-1 {
		s[i], s[j] = s[j], s[i]
	}
}

// ReverseUint16Slice reverses the given uint16 slice directly.
func ReverseUint16Slice(s []uint16) {
	for i, j := 0, len(s)-1; i < j; i, j = i+1, j-1 {
		s[i], s[j] = s[j], s[i]
	}
}

// ReverseUint32Slice reverses the given uint32 slice directly.
func ReverseUint32Slice(s []uint32) {
	for i, j := 0, len(s)-1; i < j; i, j = i+1, j-1 {
		s[i], s[j] = s[j], s[i]
	}
}

// ReverseUint64Slice reverses the given uint64 slice directly.
func ReverseUint64Slice(s []uint64) {
	for i, j := 0, len(s)-1; i < j; i, j = i+1, j-1 {
		s[i], s[j] = s[j], s[i]
	}
}
