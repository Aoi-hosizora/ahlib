package xmap

import (
	"github.com/Aoi-hosizora/ahlib/xgeneric/xtuple"
)

const (
	panicNilEachFunc      = "xslice: nil each function"
	panicNilMapFunc       = "xslice: nil map function"
	panicNilReduceFunc    = "xslice: nil reduce function"
	panicNilPredicateFunc = "xslice: nil predicate function"
)

// Keys returns a key slice of given map.
func Keys[K comparable, V any](m map[K]V) []K {
	out := make([]K, 0, len(m))
	for k := range m {
		out = append(out, k)
	}
	return out
}

// Values returns a value slice of given map.
func Values[K comparable, V any](m map[K]V) []V {
	out := make([]V, 0, len(m))
	for _, v := range m {
		out = append(out, v)
	}
	return out
}

// FromKeys generates a map, its keys are from given slice, values are generated by given mapper function.
func FromKeys[K comparable, V any](slice []K, f func(int, K) V) map[K]V {
	if f == nil {
		panic(panicNilMapFunc)
	}
	out := make(map[K]V)
	for idx, item := range slice {
		out[item] = f(idx, item)
	}
	return out
}

// FromValues generates a map, its values are from given slice, keys are generated by given mapper function.
func FromValues[K comparable, V any](slice []V, f func(int, V) K) map[K]V {
	if f == nil {
		panic(panicNilMapFunc)
	}
	out := make(map[K]V)
	for idx, item := range slice {
		out[f(idx, item)] = item
	}
	return out
}

// Foreach invokes given function for each key-value of given map.
func Foreach[K comparable, V any](m map[K]V, f func(K, V)) {
	if f == nil {
		panic(panicNilEachFunc)
	}
	for k, v := range m {
		f(k, v)
	}
}

// Map maps given map to another map using mapper function.
func Map[K1, K2 comparable, V1, V2 any](m map[K1]V1, f func(K1, V1) (K2, V2)) map[K2]V2 {
	if f == nil {
		panic(panicNilMapFunc)
	}
	out := make(map[K2]V2, len(m))
	for k, v := range m {
		k2, v2 := f(k, v)
		out[k2] = v2
	}
	return out
}

// Expand maps and expands given map to another map using expand function.
func Expand[K1, K2 comparable, V1, V2 any](m map[K1]V1, f func(K1, V1) []xtuple.Tuple[K2, V2]) map[K2]V2 {
	if f == nil {
		panic(panicNilMapFunc)
	}
	out := make(map[K2]V2, len(m))
	for k, v := range m {
		kvs := f(k, v)
		for _, kv := range kvs {
			out[kv.Item1] = kv.Item2
		}
	}
	return out
}

// Reduce reduces given map to a single value using initial value and left reducer function.
func Reduce[K comparable, V, S any](m map[K]V, initial S, f func(S, K, V) S) S {
	if f == nil {
		panic(panicNilReduceFunc)
	}
	for k, v := range m {
		initial = f(initial, k, v)
	}
	return initial
}

// Filter filters given map and returns a new map using given predicate function.
func Filter[K comparable, V any](m map[K]V, f func(K, V) bool) map[K]V {
	if f == nil {
		panic(panicNilPredicateFunc)
	}
	out := make(map[K]V)
	for k, v := range m {
		if f(k, v) {
			out[k] = v
		}
	}
	return out
}

// Any checks if given map contains a key-value pair that satisfied given predicate function.
func Any[K comparable, V any](m map[K]V, f func(K, V) bool) bool {
	if f == nil {
		panic(panicNilPredicateFunc)
	}
	if len(m) == 0 {
		return true
	}
	for k, v := range m {
		if f(k, v) {
			return true
		}
	}
	return false
}

// All checks if key-value pairs from given map that all satisfied given predicate function.
func All[K comparable, V any](m map[K]V, f func(K, V) bool) bool {
	if f == nil {
		panic(panicNilPredicateFunc)
	}
	for k, v := range m {
		if !f(k, v) {
			return false
		}
	}
	return true
}
