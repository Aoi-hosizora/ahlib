//go:build go1.18
// +build go1.18

package xgmap

import (
	"github.com/Aoi-hosizora/ahlib/xgeneric/xtuple"
)

// ==================
// fp-style functions
// ==================

const (
	panicNilEachFunc      = "xgmap: nil each function"
	panicNilMapFunc       = "xgmap: nil map function"
	panicNilReduceFunc    = "xgmap: nil reduce function"
	panicNilPredicateFunc = "xgmap: nil predicate function"
)

// Keys returns a key slice of given map. Note that returned slice has no order.
func Keys[K comparable, V any](m map[K]V) []K {
	keys := make([]K, 0, len(m))
	for k := range m {
		keys = append(keys, k)
	}
	return keys
}

// Values returns a value slice of given map. Note that returned slice has no order.
func Values[K comparable, V any](m map[K]V) []V {
	values := make([]V, 0, len(m))
	for _, v := range m {
		values = append(values, v)
	}
	return values
}

// KeyValues returns a key-value tuple slice of given map. Note that returned slice has no order.
func KeyValues[K comparable, V any](m map[K]V) []xtuple.Tuple[K, V] {
	kvs := make([]xtuple.Tuple[K, V], 0, len(m))
	for k, v := range m {
		kvs = append(kvs, xtuple.NewTuple(k, v))
	}
	return kvs
}

// FromKeys generates a map, its keys are from given slice, values are generated by given mapper function.
func FromKeys[K comparable, V any](slice []K, f func(int, K) V) map[K]V {
	if f == nil {
		panic(panicNilMapFunc)
	}
	out := make(map[K]V)
	for idx, item := range slice {
		out[item] = f(idx, item)
	}
	return out
}

// FromValues generates a map, its values are from given slice, keys are generated by given mapper function.
func FromValues[K comparable, V any](slice []V, f func(int, V) K) map[K]V {
	if f == nil {
		panic(panicNilMapFunc)
	}
	out := make(map[K]V)
	for idx, item := range slice {
		out[f(idx, item)] = item
	}
	return out
}

// FromKeyValues generates a map, its keys and values are from given kv-tuple slice.
func FromKeyValues[K comparable, V any](slice []xtuple.Tuple[K, V]) map[K]V {
	out := make(map[K]V)
	for _, kv := range slice {
		out[kv.Item1] = kv.Item2
	}
	return out
}

// Foreach invokes given function for each key-value of given map.
func Foreach[K comparable, V any](m map[K]V, f func(K, V)) {
	if f == nil {
		panic(panicNilEachFunc)
	}
	for k, v := range m {
		f(k, v)
	}
}

// Map maps given map to another map using mapper function.
func Map[K1, K2 comparable, V1, V2 any](m map[K1]V1, f func(K1, V1) (K2, V2)) map[K2]V2 {
	if f == nil {
		panic(panicNilMapFunc)
	}
	out := make(map[K2]V2, len(m))
	for k, v := range m {
		k2, v2 := f(k, v)
		out[k2] = v2
	}
	return out
}

// Expand maps and expands given map to another map using expand function.
func Expand[K1, K2 comparable, V1, V2 any](m map[K1]V1, f func(K1, V1) []xtuple.Tuple[K2, V2]) map[K2]V2 {
	if f == nil {
		panic(panicNilMapFunc)
	}
	out := make(map[K2]V2, len(m))
	for k, v := range m {
		kvs := f(k, v)
		for _, kv := range kvs {
			out[kv.Item1] = kv.Item2
		}
	}
	return out
}

// Reduce reduces given map to a single value using initial value and left reducer function.
func Reduce[K comparable, V, U any](m map[K]V, initial U, f func(U, K, V) U) U {
	if f == nil {
		panic(panicNilReduceFunc)
	}
	for k, v := range m {
		initial = f(initial, k, v)
	}
	return initial
}

// Filter filters given map and returns a new map using given predicate function.
func Filter[M ~map[K]V, K comparable, V any](m M, f func(K, V) bool) M {
	if f == nil {
		panic(panicNilPredicateFunc)
	}
	out := make(map[K]V)
	for k, v := range m {
		if f(k, v) {
			out[k] = v
		}
	}
	return out
}

// Any checks whether given map contains a key-value pair that satisfied given predicate function.
func Any[K comparable, V any](m map[K]V, f func(K, V) bool) bool {
	if f == nil {
		panic(panicNilPredicateFunc)
	}
	if len(m) == 0 {
		return true
	}
	for k, v := range m {
		if f(k, v) {
			return true
		}
	}
	return false
}

// All checks whether key-value pairs from given map that all satisfied given predicate function.
func All[K comparable, V any](m map[K]V, f func(K, V) bool) bool {
	if f == nil {
		panic(panicNilPredicateFunc)
	}
	for k, v := range m {
		if !f(k, v) {
			return false
		}
	}
	return true
}

// ====================================
// functions from golang.org/x/exp/maps
// ====================================

// Equal reports whether two maps contain the same key/value pairs. Values are compared using `==`.
func Equal[M ~map[K]V, K, V comparable](m1, m2 M) bool {
	return EqualWith(m1, m2, func(i, j V) bool { return i == j })
}

// EqualWith is like Equal, but compares values using given equaller.
func EqualWith[M1 ~map[K]V1, M2 ~map[K]V2, K comparable, V1, V2 any](m1 M1, m2 M2, equaller func(V1, V2) bool) bool {
	if len(m1) != len(m2) {
		return false
	}
	for k, v1 := range m1 {
		if v2, ok := m2[k]; !ok || !equaller(v1, v2) {
			return false
		}
	}
	return true
}

// Clone returns a copy of given map, and the elements are copied using assignment.
func Clone[M ~map[K]V, K comparable, V any](m M) M {
	newMap := make(M, len(m))
	for k, v := range m {
		newMap[k] = v
	}
	return newMap
}

// CopyTo copies all key-value pairs in src to dst.
func CopyTo[K comparable, V any](dst, src map[K]V) {
	for k, v := range src {
		dst[k] = v
	}
}

// Clear removes all entries from given map, leaving it empty.
func Clear[M ~map[K]V, K comparable, V any](m M) {
	for k := range m {
		delete(m, k)
	}
}
