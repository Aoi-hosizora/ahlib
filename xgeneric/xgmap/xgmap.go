//go:build go1.18
// +build go1.18

package xgmap

import (
	"github.com/Aoi-hosizora/ahlib/xgeneric/xtuple"
)

// TODO
// https://github.com/zyedidia/generic
// https://pkg.go.dev/golang.org/x/exp/maps

// ==================
// fp-style functions
// ==================

const (
	panicNilEachFunc      = "xgmap: nil each function"
	panicNilMapFunc       = "xgmap: nil map function"
	panicNilReduceFunc    = "xgmap: nil reduce function"
	panicNilPredicateFunc = "xgmap: nil predicate function"
)

// Keys returns a key slice of given map. Note that returned slice has no order.
func Keys[K comparable, V any](m map[K]V) []K {
	keys := make([]K, 0, len(m))
	for k := range m {
		keys = append(keys, k)
	}
	return keys
}

// Values returns a value slice of given map. Note that returned slice has no order.
func Values[K comparable, V any](m map[K]V) []V {
	values := make([]V, 0, len(m))
	for _, v := range m {
		values = append(values, v)
	}
	return values
}

// KeyValues returns a key-value tuple slice of given map. Note that returned slice has no order.
func KeyValues[K comparable, V any](m map[K]V) []xtuple.Tuple[K, V] {
	kvs := make([]xtuple.Tuple[K, V], 0, len(m))
	for k, v := range m {
		kvs = append(kvs, xtuple.NewTuple(k, v))
	}
	return kvs
}

// FromKeys generates a map, its keys are from given slice, values are generated by given mapper function.
func FromKeys[K comparable, V any](slice []K, f func(int, K) V) map[K]V {
	if f == nil {
		panic(panicNilMapFunc)
	}
	out := make(map[K]V)
	for idx, item := range slice {
		out[item] = f(idx, item)
	}
	return out
}

// FromValues generates a map, its values are from given slice, keys are generated by given mapper function.
func FromValues[K comparable, V any](slice []V, f func(int, V) K) map[K]V {
	if f == nil {
		panic(panicNilMapFunc)
	}
	out := make(map[K]V)
	for idx, item := range slice {
		out[f(idx, item)] = item
	}
	return out
}

// FromKeyValues generates a map, its keys and values are from given kv-tuple slice.
func FromKeyValues[K comparable, V any](slice []xtuple.Tuple[K, V]) map[K]V {
	out := make(map[K]V)
	for _, kv := range slice {
		out[kv.Item1] = kv.Item2
	}
	return out
}

// Foreach invokes given function for each key-value of given map.
func Foreach[K comparable, V any](m map[K]V, f func(K, V)) {
	if f == nil {
		panic(panicNilEachFunc)
	}
	for k, v := range m {
		f(k, v)
	}
}

// Map maps given map to another map using mapper function.
func Map[K1, K2 comparable, V1, V2 any](m map[K1]V1, f func(K1, V1) (K2, V2)) map[K2]V2 {
	if f == nil {
		panic(panicNilMapFunc)
	}
	out := make(map[K2]V2, len(m))
	for k, v := range m {
		k2, v2 := f(k, v)
		out[k2] = v2
	}
	return out
}

// Expand maps and expands given map to another map using expand function.
func Expand[K1, K2 comparable, V1, V2 any](m map[K1]V1, f func(K1, V1) []xtuple.Tuple[K2, V2]) map[K2]V2 {
	if f == nil {
		panic(panicNilMapFunc)
	}
	out := make(map[K2]V2, len(m))
	for k, v := range m {
		kvs := f(k, v)
		for _, kv := range kvs {
			out[kv.Item1] = kv.Item2
		}
	}
	return out
}

// Reduce reduces given map to a single value using initial value and left reducer function.
func Reduce[K comparable, V, U any](m map[K]V, initial U, f func(U, K, V) U) U {
	if f == nil {
		panic(panicNilReduceFunc)
	}
	for k, v := range m {
		initial = f(initial, k, v)
	}
	return initial
}

// Filter filters given map and returns a new map using given predicate function.
func Filter[K comparable, V any, M ~map[K]V](m M, f func(K, V) bool) M {
	if f == nil {
		panic(panicNilPredicateFunc)
	}
	out := make(map[K]V)
	for k, v := range m {
		if f(k, v) {
			out[k] = v
		}
	}
	return out
}

// Any checks whether given map contains a key-value pair that satisfied given predicate function.
func Any[K comparable, V any](m map[K]V, f func(K, V) bool) bool {
	if f == nil {
		panic(panicNilPredicateFunc)
	}
	if len(m) == 0 {
		return true
	}
	for k, v := range m {
		if f(k, v) {
			return true
		}
	}
	return false
}

// All checks whether key-value pairs from given map that all satisfied given predicate function.
func All[K comparable, V any](m map[K]V, f func(K, V) bool) bool {
	if f == nil {
		panic(panicNilPredicateFunc)
	}
	for k, v := range m {
		if !f(k, v) {
			return false
		}
	}
	return true
}
